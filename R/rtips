R tips:

install.packages("mypkg", dependencies=TRUE)
library("mypkg")

-------------------------------------------------

?"["
for help on syntax of indexing.  (There's more to it than you think!)

-------------------------------------------------

> s
 [1]  1  1  1  1  1  1  2  3  4  4  7  9  9  9 14 22 27 27
> s[s>8 & s<15]
[1]  9  9  9 14

-------------------------------------------------

> both1500mm

              ah1500mm  ap1500mm
RUN007333410 0.5361030 0.5206731
RUN062627571 0.1800633 0.3004472
RUN212802379 0.7162206 0.6941171
RUN233713014 0.5369362 0.6947981
RUN281044718 0.5353132 0.4960339
RUN423135909 0.6521371 0.2998646
RUN442947334 0.5357295 0.2997922
RUN498437660 0.7123269 0.4961410
RUN572523585 0.7122199 0.4962430
RUN589641714 0.8924261 0.8912864
RUN637198734 0.5352445 0.3008475
RUN800763153 0.8906272 0.6938957
RUN903654108 0.5349658 0.6932277
RUN991213397 0.3578725 0.4975654

> both1500mm[both1500mm[,1]>.5 & both1500mm[,1]<.6, ]

              ah1500mm  ap1500mm
RUN007333410 0.5361030 0.5206731
RUN233713014 0.5369362 0.6947981
RUN281044718 0.5353132 0.4960339
RUN442947334 0.5357295 0.2997922
RUN637198734 0.5352445 0.3008475
RUN903654108 0.5349658 0.6932277

> both1500mm[both1500mm[,1]>.45 & both1500mm[,1]<.6 & both1500mm[,2]>.45 & both1500mm[,2]<.6,]

              ah1500mm  ap1500mm
RUN007333410 0.5361030 0.5206731
RUN281044718 0.5353132 0.4960339

-------------------------------------------------
SORTING:

> yo
         x        y        z
1 0.000031 0.000183 0.000824
2 0.044495 0.155732 0.533939
3 0.822440 0.873416 0.838542
4 0.322291 0.648545 0.990648
5 0.393595 0.826873 0.418881
> ya <- yo[order(yo["y"]),]
> ya
         x        y        z
1 0.000031 0.000183 0.000824
2 0.044495 0.155732 0.533939
4 0.322291 0.648545 0.990648
5 0.393595 0.826873 0.418881
3 0.822440 0.873416 0.838542
> 

-------------------------------------------------
To time a function call:

system.time(expression)

-------------------------------------------------

# a <- read2multirunRA(csvs)   # defined below: create multi-run array
# ah <- multiRA2domRA(a, "H")  # defined below: extract subarray for proposition domain H
# ap <- multiRA2domRA(a, "P")
# ah1500 <- ah[,,1500,]        # extract subarrays for timestep 1500
# ap1500 <- ap[,,1500,]
# ah1500means <- apply(ah1500, c(1,3), mean)  # get average activation for each person in each run
# ap1500means <- apply(ap1500, c(1,3), mean)
# ap1500means - ah1500means                   # crude display of difference between H and P activations
# sum(ap1500means - ah1500means)              # even cruder check to see which is greater on average
# ap1500means/ah1500means                     # ratios are also interesting

-------------------------------------------------
notes on apply()

apply(data, margin, fn):

The documentation says:
MARGIN	a vector giving the subscripts which the function will be applied over.

I would say:
Margin is the number of the dimension, or a vec of dimensions,
which are *not* averaged over.  
e.g.:
> yo <- matrix(1:12, nrow=3, ncol=4)
> yo
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

apply(yo, 1, mean) goes to each row (dimension 1) index, and
averages over all elements in that row--i.e. over columns in that row.

apply(yo, 2, mean) goes to each column (dimension 2) index, and computes
the average for all elements in that column.  

e.g.:
> ya <- array(1:24, c(3,4,2))
> ya
, , 1

     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

, , 2

     [,1] [,2] [,3] [,4]
[1,]   13   16   19   22
[2,]   14   17   20   23
[3,]   15   18   21   24

> apply(ya, c(2,3), mean)
     [,1] [,2]
[1,]    2   14
[2,]    5   17
[3,]    8   20
[4,]   11   23
That gives the average over row indexed elements for each combination of
indexes in dimensions 2 (cols) and 3 (2D matrices).  Note though that
the results are flipped diagonally from what I'd expect: The first
column corresponds to the middle row of the first matrix, and the second
column corresponds to the middle row of the second matrix, since these
middle row elements happen to equal the average across each column
within each matrix.

> apply(ya, c(1,2), mean)
     [,1] [,2] [,3] [,4]
[1,]    7   10   13   16
[2,]    8   11   14   17
[3,]    9   12   15   18
That gives the average for the 2 corresponding elements in each 
of the 2 matrices which 1, 2 in the third dimension index.

> apply(ya, c(1,3), mean)
     [,1] [,2]
[1,]  5.5 17.5
[2,]  6.5 18.5
[3,]  7.5 19.5
These are the averages for each row within a 2D matrix, i.e. we allow
column indexes to vary, and average over the resulting values, for each
row and matrix index.



-------------------------------------------------
[df2ra is from my popco/R/df2ra.R]

> r1 <- df2ra(d1)
> r2 <- df2ra(d2)
> yo <- c(as.vector(r1), as.vector(r2))
> dim(yo)
NULL
> length(yo)
[1] 54000
> ya <- array(yo, c(10,27,200))
> all(r1 == ya[,,101:200])
[1] FALSE
> all(r2 == ya[,,101:200])
[1] TRUE
> all(r1 == ya[,,1:100])
[1] TRUE
> dim(ya)
[1]  10  27 200

> ra <- array(yo, c(10, 27, 100, 2))
> dim(ra)
[1]  10  27 100   2
> all(r1 == ra[,,,1])
[1] TRUE
> all(r2 == ra[,,,2])
[1] TRUE
> all(r1 == ra[,,,2])

> newdimnames <- dimnames(r1)
> newdimnames[[4]] <- c("run1", "run2")
> rb <- array(c(as.vector(r1), as.vector(r2)), c(10, 27, 100, 2), dimnames=newdimnames)
> all(ra == rb)
[1] TRUE


RAs2multirunRA <- function(...) {
  ras <- c(...)
}

-------------------------------------------------

to clear the console in OX X, cmd-opt-L.

to get data, try something like
var <- read.csv("mypath")
var is called a data frame
Then you can refer to columns by name as var$colname, 
or refer to cols by index as var[i]

here is something bizarre:
var[2] refers to the second column
var[3,2] refers to the third entry in the second column
var[3,] refers to the third row

to set/get the directory, use getwd() and setwd(path)
to load a script, use source(script)

for (i in 1:519){names<-colnames(tst); if (pmatch("CHRIS",names[i],nomatch=0)) {print(names[i])}}

 for (n in grep(paste0("CHRIS", "_OE"), colnames(data), value=TRUE)) { # grep searches through array colnames(data)
   cat(n)                                                              # returning elements that match
   cat(": ")
   cat(tst[2,n])  # here we are using the returned name as the column index, and 2 as the row index
   cat("\n")
 }


To concatenate two data frames in the sense of adding their rows to make new df with the
same columns but as many rows as both combined, use rbind(df1, df2, ...).

I think cbind might do something similar for adding the second one as new columns, etc.
