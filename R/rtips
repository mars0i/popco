R tips:

install.packages("mypkg", dependencies=TRUE)
library("mypkg")

-------------------------------------------------
To time a function call:

system.time(expression)

-------------------------------------------------

# a <- read2multirunRA(csvs)   # defined below: create multi-run array
# ah <- multiRA2domRA(a, "H")  # defined below: extract subarray for proposition domain H
# ap <- multiRA2domRA(a, "P")
# ah1500 <- ah[,,1500,]        # extract subarrays for timestep 1500
# ap1500 <- ap[,,1500,]
# ah1500means <- apply(ah1500, c(1,3), mean)  # get average activation for each person in each run
# ap1500means <- apply(ap1500, c(1,3), mean)
# ap1500means - ah1500means                   # crude display of difference between H and P activations
# sum(ap1500means - ah1500means)              # even cruder check to see which is greater on average
# ap1500means/ah1500means                     # ratios are also interesting

-------------------------------------------------
notes on apply()

apply(data, margin, fn):

The documentation says:
MARGIN	a vector giving the subscripts which the function will be applied over.

I would say:
Margin is the number of the dimension, or a vec of dimensions,
which are *not* averaged over.  
e.g.:
> yo <- matrix(1:12, nrow=3, ncol=4)
> yo
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

apply(yo, 1, mean) goes to each row (dimension 1) index, and
averages over all elements in that row--i.e. over columns in that row.

apply(yo, 2, mean) goes to each column (dimension 2) index, and computes
the average for all elements in that column.  

e.g.:
> ya <- array(1:24, c(3,4,2))
> ya
, , 1

     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

, , 2

     [,1] [,2] [,3] [,4]
[1,]   13   16   19   22
[2,]   14   17   20   23
[3,]   15   18   21   24

> apply(ya, c(2,3), mean)
     [,1] [,2]
[1,]    2   14
[2,]    5   17
[3,]    8   20
[4,]   11   23
That gives the average over row indexed elements for each combination of
indexes in dimensions 2 (cols) and 3 (2D matrices).  Note though that
the results are flipped diagonally from what I'd expect: The first
column corresponds to the middle row of the first matrix, and the second
column corresponds to the middle row of the second matrix, since these
middle row elements happen to equal the average across each column
within each matrix.

> apply(ya, c(1,2), mean)
     [,1] [,2] [,3] [,4]
[1,]    7   10   13   16
[2,]    8   11   14   17
[3,]    9   12   15   18
That gives the average for the 2 corresponding elements in each 
of the 2 matrices which 1, 2 in the third dimension index.

> apply(ya, c(1,3), mean)
     [,1] [,2]
[1,]  5.5 17.5
[2,]  6.5 18.5
[3,]  7.5 19.5
These are the averages for each row within a 2D matrix, i.e. we allow
column indexes to vary, and average over the resulting values, for each
row and matrix index.



-------------------------------------------------
[df2ra is from my popco/R/df2ra.R]

> r1 <- df2ra(d1)
> r2 <- df2ra(d2)
> yo <- c(as.vector(r1), as.vector(r2))
> dim(yo)
NULL
> length(yo)
[1] 54000
> ya <- array(yo, c(10,27,200))
> all(r1 == ya[,,101:200])
[1] FALSE
> all(r2 == ya[,,101:200])
[1] TRUE
> all(r1 == ya[,,1:100])
[1] TRUE
> dim(ya)
[1]  10  27 200

> ra <- array(yo, c(10, 27, 100, 2))
> dim(ra)
[1]  10  27 100   2
> all(r1 == ra[,,,1])
[1] TRUE
> all(r2 == ra[,,,2])
[1] TRUE
> all(r1 == ra[,,,2])

> newdimnames <- dimnames(r1)
> newdimnames[[4]] <- c("run1", "run2")
> rb <- array(c(as.vector(r1), as.vector(r2)), c(10, 27, 100, 2), dimnames=newdimnames)
> all(ra == rb)
[1] TRUE


RAs2multirunRA <- function(...) {
  ras <- c(...)
}

-------------------------------------------------

to clear the console in OX X, cmd-opt-L.

to get data, try something like
var <- read.csv("mypath")
var is called a data frame
Then you can refer to columns by name as var$colname, 
or refer to cols by index as var[i]

here is something bizarre:
var[2] refers to the second column
var[3,2] refers to the third entry in the second column
var[3,] refers to the third row

to set/get the directory, use getwd() and setwd(path)
to load a script, use source(script)

for (i in 1:519){names<-colnames(tst); if (pmatch("CHRIS",names[i],nomatch=0)) {print(names[i])}}

 for (n in grep(paste0("CHRIS", "_OE"), colnames(data), value=TRUE)) { # grep searches through array colnames(data)
   cat(n)                                                              # returning elements that match
   cat(": ")
   cat(tst[2,n])  # here we are using the returned name as the column index, and 2 as the row index
   cat("\n")
 }


To concatenate two data frames in the sense of adding their rows to make new df with the
same columns but as many rows as both combined, use rbind(df1, df2, ...).

I think cbind might do something similar for adding the second one as new columns, etc.
