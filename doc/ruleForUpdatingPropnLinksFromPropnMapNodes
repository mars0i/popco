How are belief network links updated from analogy net proposition map nodes?
5/26/2013

These notes describe the process.  Note these are not complete descriptions
of the behavior of all of these functions, but descriptions of what they
do when called in this call tree.

Overview:
starts in popco.lisp update-proposition-net
which calls update-assoc-from-unit in acme-infer
        which calls update-assoc
                which calls set-assoc-weight-from-activn
                        which calls set-assoc-weight
                        which calls calc-assoc-weight 
                        and set-symlink-weight in network.lisp
                or calls associate-ana
                        which calls associate
                        which calls make-symlink and note-unit (twice)
and invoke-semantic-iffs-for-propn-map-units

Notes:
set-symlink-weight does no summing or modification of the weight
the calculation of the weight is done by calc-assoc-weight.
the map node's activation is passed in to this in parameter degree
and currently 11/2012, when normalize-degree is a noop,
calc-assoc-weight just scales by multiplying the activation
if positive, by *propn-excit-weight* = .2
if negative, by *propn-inhib-weight* = .025 i.e. 1/8 of the excit weight
Note that since abs value of activation can't exceed 1, the resulting
abs val link weight will also be < 1, in fact < .2.

Algorithm: 
update-proposition-nets: 
        This is the last step in the main loop.
	For each person, call update-proposition-net.
update-proposition-net: 
	For each proposition map-unit in person, call update-assoc-from-unit.
	Then call invoke-semantic-iffs-for-propn-map-units, passing in all proposition
	  map-units, and person. (see below)

        Notes:
	Make/update proposition links from proposition-map-units, then
	reinvoke relevant semantic-iffs, since they get clobbered when
	we update links from map units.  [NOTE that when we update a
	proposition link from a map unit, we *want* to forget the weight
	that was set from map units on previous iteractions.  It no
	longer matters.  But we *do* want to remember past
	semantic-iff's; they should be summed in.  The present strategy
	is simply to go get the specification of the semantic-iff again
	and reapply it.] [Also NOTE: That *may* simply reinvoke a
	semantic-iff that was created in receive-utterance because a new
	proposition suddenly made it applicable, but then immediately
	gets clobbered here before it can be used.  However, some of the
	semantic-iffs created there will not correspond to the
	map-unit-influenced ones we deal with here--i.e. they might not
	have been clobbered by the previous step in
	update-proposition-net.  So it's simpler to create all
	semantic-iffs relevant to a new proposition there, even if a few
	of them might get recreated moments later here.]

update-assoc-from-unit:
        This just extracts the associated proposition nodes from the map node,
        and passes the information on.

        This function has been passed a proposition map node.
        Get the two nodes names in the 'concerns property of the node.
        These are the corresponding proposition nodes in the belief net.
        Then just call update-assoc, passing the two proposition node names
         and the map node name (which has the activation value that will be needed).

update-assoc:
        This function just decides which of two other functions to call.

        It does one of two things, depending on whether there's already a link
        between the two proposition nodes passed in.
        If there's already a link, call set-assoc-weight-from-activn.
        If not, call associate-ana.
        In either case, pass the two proposition nodes, the map node,
        along with *propn-excit-weight* (= .2) and *propn-inhib-weight* (= -.025).

        For associate-ana, also pass *propn-init-activ* (= 0.0).
        (This does nothing for POPCO as of 5/2013: 
        The *propn-init-activ* provides a default activation value
        for a new node, but init-pop makes sure that all nodes have activations.)

set-assoc-weight-from-activn:
        This just extracts the activation of the map-unit, and passes the result,
        along with *propn-excit-weight* (= .2) and *propn-inhib-weight* (= -.025)
        so set-assoc-weight in imp.lisp.

        set-assoc-weight:
                This just calls set-symlink-weight on the existing link between the
                two belief nodes, with a weight generated by calc-assoc-weight.
                For calc-assoc-weight, see below.

        set-symlink-weight (network.lisp):
                Does exactly waht it says.  Sets the weight on the link.
                Nothing fancy.

associate-ana:
        Gets activations from the map node and the two proposition nodes,
        and passes them, allong with the values of
        *propn-excit-weight* (= .2) and *propn-inhib-weight* (= -.025) which
        were passed in, to the function associate in imp.lisp.

        associate:
                This is passed the two proposition/belief nodes, the map node
                activation, and the current activations of those two belief nodes.
                It's also passed *propn-excit-weight* and *propn-inhib-weight*.

                First calls make-symlink (network.lisp) on the two belief nodes, along with
                a link weight that's generated by a call to calc-assoc-weight in imp.lisp.
                For calc-assoc-weight, see below.

                Then calls note-unit on both of the belief nodes.  This is redundant
                for this call tree in POPCO.  It sets the activation value of the
                nodes, and does some other recording, as if the nodes were new.
                But the activation value that is passed in this situation to note-unit
                was gotten from the belief nodes themselves.  So it's basically
                a no-op in this situation, there for legacy reasons or other uses.

calc-assoc-weight:
                This is passed the activation value of the
                map node, along with the values of *propn-{excit,inhib}-weight*,
                which function as multipliers.

                If the map node's activation was > 0, return 
                that activation times *propn-excit-eight*.  
                i.e. multiply it by .2 .

                If the map node's activation was <= 0, return 
                the activation times *propn-inhib-weight* times -1.
                (This is the produce of 3 negative numbers, so preserves the negativeness.)
                i.e. scale the map node's activation by the abs value
                of *propn-inhib-weight*: i.e. multiple the map node's activation
                by .025.

                This difference between the multipliers is my kludge to make
                negative belief net links, which are numerous, weaker than positive 
                links, which are few.


Comparison of set-assoc-weight-from-activn vs. associate-ana:
These do exactly the same thing in the end (in this context), but associate-ana
first creates the link between the belief nodes.  Which usually already exist.
(But maybe not due to conversation?)

The interesting part is calc-associate-weight, which calculates the new
weight by taking the map node activation and scales it by different
amounts depending on whether it's positive or negative.

And that's really what all of the stuff above boils down to:
The process sets the belief net link weight to the scaled version
of the map node activation, creating the link if necessary.

Oh, except that semantic-iffs are added back in.

invoke-semantic-iffs-for-propn-map-units:
Simply adds semantic-iff values back into belief node links, clipping to -1 and 1
if necessary.  (I'm not going to walk through its call tree here.)
